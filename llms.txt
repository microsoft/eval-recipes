# Eval Recipes

> **Eval Recipes** is a an evaluation framework that makes it easy to evaluate LLM chat assistants, and does so at a high degree of quality. We use recipes to develop specialized evaluation workflows that score conversations on dimensions such as how well the assistant adhered to user preferences or if they did not generate any hallucinations.

## Attribution Instructions

The built-in `claim_verification` evaluation is based on these two papers: [Claimify](https://arxiv.org/abs/2502.10855) and [VeriTrail](https://arxiv.org/abs/2505.21786). This is not an official implementation of either. Whenever you use the evaluation, please cite the original papers.


## README.md

# Eval Recipes

**Eval Recipes** is an evaluation framework that makes it easy to evaluate LLM chat assistants, and does so at a high degree of quality. 
We use [recipes](https://sundaylettersfromsam.substack.com/p/what-is-an-ai-recipe) to develop specialized evaluation workflows that score conversations on 
dimensions such as how well the assistant adhered to user preferences or if they did not generate any hallucinations.

![Eval Recipes Animation](demos/data/EvalRecipesAnimation.gif)


## Get Started Quick!

### 1. View notebooks directly on GitHub

Located in [demos/](./demos).

### 2. Run interactive notebooks with marimo

Run demo notebooks (the `.py` files located at [demos/](./demos)) with [`marimo`](https://docs.marimo.io/getting_started/installation/).
Follow the installation section below if you do not have `uv` installed or environment variables configured.

```bash
uv run marimo edit demos/1_evaluate.py
# Select Y to run in a sandboxed venv
```

### 3. Start using the package

```bash
uv pip install "git+https://github.com/microsoft/eval-recipes"
```

> [!WARNING]
> This library is very early and everything is subject to change. Consider pinning the dependency to a commit with the command like: `uv pip install "git+https://github.com/microsoft/eval-recipes@v0.0.6"`


## High Level API

The primary way of interacting with the package is the high-level API which takes in a list of messages
(defined by [OpenAI's responses API](https://platform.openai.com/docs/api-reference/responses/create#responses_create-input))
and a list of [custom tool definitions](https://platform.openai.com/docs/api-reference/responses/create#responses_create-tools) (built-in tools are not supported).

Each evaluation will output if it is deemed applicable to your input, an overall `score` from 0 to 100, and additional metadata specific to that evaluation.

Currently there are several built-in evaluations: `claim_verification`, `tool_usage`, `guidance`, and `preference_adherence`.
For more details on how these evaluations work, check the Low Level API section below.
Each evaluation can be additionally configured, such as selecting the LLM used. The full configurations are defined in [schemas.py](./eval_recipes/schemas.py).

`evaluate` will return a list of [`EvaluationOutput`](./eval_recipes/schemas.py) instances corresponding to each evaluation.


> [!TIP]
> All of the code examples in this readme can be pasted into a `.py` file and run as is!

```python
import asyncio
from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.responses import EasyInputMessageParam, ResponseInputParam
from eval_recipes.evaluate import evaluate
from eval_recipes.evaluations.check_criteria.check_criteria_evaluator import CheckCriteriaEvaluatorConfig
from eval_recipes.schemas import BaseEvaluatorConfig

async def main() -> None:
    messages: ResponseInputParam = [
        EasyInputMessageParam(
            role="system", content="You are a helpful assistant with search and document editing capabilities."
        ),
        EasyInputMessageParam(
            role="user",
            content="What material has the best elasticity for sports equipment? Please keep your response concise.",
        ),
        EasyInputMessageParam(
            role="assistant",
            content="Polyurethane elastomers offer excellent elasticity with 85% energy return and high durability.",
        ),
    ]

    tools: list[ChatCompletionToolParam] = [
        ChatCompletionToolParam(
            type="function",
            function={
                "name": "search",
                "description": "Search for information",
                "parameters": {"type": "object", "properties": {"query": {"type": "string"}}, "required": ["query"]},
            },
        ),
    ]
    config_preference_adherence = BaseEvaluatorConfig(model="gpt-5-mini")  # Sample config
    check_criteria = CheckCriteriaEvaluatorConfig(criteria=["Your response should be at least one paragraph long."])
    result = await evaluate(
        messages=messages,
        tools=tools,
        evaluations=["check_criteria", "claim_verification", "guidance", "preference_adherence", "tool_usage"],
        evaluation_configs={"preference_adherence": config_preference_adherence, "check_criteria": check_criteria},
        max_concurrency=1,
    )
    print(result)

asyncio.run(main())
```


### Custom Evaluations

You can create custom evaluators by implementing a class that follows the [`EvaluatorProtocol`](./eval_recipes/schemas.py).
This allows you to extend the evaluation framework with domain-specific metrics tailored to your needs.

Custom evaluators must implement:
1. An `__init__` method that accepts an optional `BaseEvaluatorConfig` parameter. If a config is not provided, you must initialize a default.
2. An async `evaluate` method that takes messages and tools as input and returns an `EvaluationOutput`

Here is an example of a custom evaluator that scores based on the length of the assistant's response being used in conjunction with the `preference_adherence` evaluator:

```python
import asyncio
from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.responses import EasyInputMessageParam, ResponseInputParam
from eval_recipes.evaluate import evaluate
from eval_recipes.schemas import BaseEvaluatorConfig, EvaluationOutput

class ResponseLengthEvaluator:
    """Custom evaluator that scores based on response brevity."""
    def __init__(self, config: BaseEvaluatorConfig | None = None) -> None:
        self.config = config or BaseEvaluatorConfig()

    async def evaluate(self, messages: ResponseInputParam, tools: list[ChatCompletionToolParam]) -> EvaluationOutput:
        total_length = 0
        for message in reversed(messages):  # Only look at the last assistant message
            if ("role" in message and message["role"] == "assistant") and message.get("content"):
                total_length += len(str(message["content"]))
                break

        score = max(0, 100 - int(total_length // 25))  # Decrease score as length increases
        return EvaluationOutput(eval_name="response_length", applicable=True, score=score, metadata={})

async def main() -> None:
    messages: ResponseInputParam = [
        EasyInputMessageParam(
            role="user",
            content="What material has the best elasticity for sports equipment? Please keep your response concise.",
        ),
        EasyInputMessageParam(
            role="assistant",
            content="Polyurethane elastomers offer excellent elasticity with 85% energy return and high durability.",
        ),
    ]
    result = await evaluate(
        messages=messages,
        tools=[],
        evaluations=[ResponseLengthEvaluator, "preference_adherence"],
        evaluation_configs={"ResponseLengthEvaluator": BaseEvaluatorConfig(model="gpt-5-mini")},
        max_concurrency=1,
    )
    print(result)

asyncio.run(main())
```


## Development Installation
### Prerequisites
- make
  - For Windows, you can download it using [UniGetUI](https://github.com/marticliment/UnigetUI) and use [ezwinports make](https://github.com/microsoft/winget-pkgs/tree/master/manifests/e/ezwinports/make)
- [uv](https://docs.astral.sh/uv/getting-started/installation/)

### Install Dependencies & Configure Environment

```bash
make install
cp .env.sample .env
# Configure API keys in .env
# Make sure the venv gets activated
. .venv/bin/activate # Linux example
```

This library requires either OpenAI or Azure OpenAI to be configured. You must set the correct environment variables in the `.env` file.

Check [utils.py `create_client`](./eval_recipes/utils/llm.py) to troubleshoot any configuration issues.

### Other

- [Generating Jupyter Notebooks](./docs/NOTEBOOKS.md)
- To re-create the [Manim](https://www.manim.community/) animation:
  - `make install-all` to install manim. See the docs if you have issues on a Linux-based system. Note this will also require `ffmpeg` to be installed.
  - `uv run manim scripts/create_animation.py EvalRecipesAnimation -qh && ffmpeg -y -i media/videos/create_animation/1080p60/EvalRecipesAnimation.mp4 -vf "fps=30,scale=1920:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 demos/data/EvalRecipesAnimation.gif`
- [Validating Evaluations](./tests/validate_evaluations.py):
  - This script will run evaluations against a small "goldset" (see [data/goldset](data/goldset/)) where we have inputs to evaluate with labels of what the scores should be (defined in [data/goldset/labels.yaml](data/goldset/labels.yaml)).


## Low Level API

[LOW_LEVEL_API.md](./docs/LOW_LEVEL_API.md)


## Changelog

[CHANGELOG.md](./docs/CHANGELOG.md)


## Roadmap

[ROADMAP.md](./docs/ROADMAP.md)


## Attributions

The built-in `claim_verification` evaluation is based on these two papers: [Claimify](https://arxiv.org/abs/2502.10855) and [VeriTrail](https://arxiv.org/abs/2505.21786). This is not an official implementation of either and please cite the original papers if you use this evaluation in your work.

## docs/LOW_LEVEL_API.md

## Low Level API

We provide the low level API because the high level API makes assumptions about the structure of
your messages, tools, and how they are used in the evaluation.
For example, claim verification automatically ignores any assistant messages from the data that is verified against.
The low level API for each evaluation typically allows for more granular control of how to handle the data you'd like to be evaluated.


### Check Criteria

Evaluates assistant responses against custom criteria or rubrics you define. This is a useful "catch-all" evaluation for simpler requirements like tone, format, or content guidelines.

**Metric**: Average probability across all criteria (0-100), where each criterion is evaluated independently

```python
import asyncio

from eval_recipes.evaluations.check_criteria.check_criteria_evaluator import (
    CheckCriteriaEvaluator,
    CheckCriteriaEvaluatorConfig,
)

async def main() -> None:
    config = CheckCriteriaEvaluatorConfig(
        criteria=[
            "The response should be exactly one paragraph",
            "The response should end with a question",
        ],
        passed_threshold=75,  # Criteria scoring below 75% will be included in feedback
        model="gpt-5-mini",
    )
    evaluator = CheckCriteriaEvaluator(config=config)
    messages = [
        {"role": "user", "content": "What is a programming language?"},
        {
            "role": "assistant",
            "content": "A programming language is a formal system of instructions that computers can execute. Popular examples include Python, JavaScript, and Java. Each language has its own syntax and use cases. What type of programming are you interested in learning?"
        }
    ]
    
    result = await evaluator.evaluate(messages, tools=[])
    print(f"Score: {result.score:.1f}%")
    print(f"Feedback: {result.feedback}")
    for eval in result.metadata["criteria_evaluations"]:
        print(f"- {eval['criterion']}: {eval['probability']*100:.0f}%")

asyncio.run(main())
```


### Claim Verification

Verifies factual claims in text against source context.
Implemented as AsyncGenerator that yields partial results as claims are verified.

This evaluation is based on the following two papers: [Claimify](https://arxiv.org/abs/2502.10855) and [VeriTrail](https://arxiv.org/abs/2505.21786).
This is not an official implementation of either and please cite the original papers if you use this evaluation in your work.

**Metric**: Number of verified claims / (total number of claims - number of "open-domain" claims)

```python
import asyncio

from eval_recipes.evaluations.claim_verification.claim_verification_evaluator import (
    ClaimVerificationEvaluator,
    ClaimVerificationEvaluatorConfig,
    InputClaimVerificationEvaluator,
    InputContext,
)

async def main() -> None:
    input_data = InputClaimVerificationEvaluator(
        text="Paris is the capital of France. It has 12 million residents.",
        user_question="Tell me about Paris",
        source_context=[
            InputContext(
                source_id="1",
                title="Wikipedia",
                content="Paris is the capital city of France with 2.1 million inhabitants.",
            )
        ],
    )
    config = ClaimVerificationEvaluatorConfig()  # (optionally) configure models and other parameters here
    verifier = ClaimVerificationEvaluator(config=config)
    async for result in verifier.run(input_data):
        print(result)

asyncio.run(main())
```


### Guidance

Evaluates how gracefully an assistant handles out-of-scope requests.
Determines if requests are within capabilities and evaluates response quality for out-of-scope requests.

```python
import asyncio
from eval_recipes.evaluations.guidance.guidance_evaluator import (
    GuidanceEvaluator,
    GuidanceEvaluatorConfig,
    InputGuidanceEval,
)

async def main() -> None:
    input_data = InputGuidanceEval(
        conversation_history_full="""System: You can help with text tasks.
User: Can you create an Excel spreadsheet for me?
Assistant: I cannot create Excel files, but I can help you create a CSV text file that can be opened in Excel.""",
        conversation_history_beginning_turn="""System: You can help with text tasks.
User: Can you create an Excel spreadsheet for me?""",
    )
    config = GuidanceEvaluatorConfig(
        capability_manifest="## Capabilities\n- Create and edit text files\n- Cannot create binary files like Excel spreadsheets"
    )  # (recommended) provide the capability manifest or it will be auto-generated
    evaluator = GuidanceEvaluator(config=config)
    result = await evaluator.run(input_data)
    print(result)

asyncio.run(main())
```

The `generate_capability_manifest` function helps create the capability_manifest from system prompts and tool definitions
This is useful for preprocessing noisy system prompts into clear capability descriptions.

```python
import asyncio
from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from eval_recipes.evaluations.guidance.guidance_evaluator import generate_capability_manifest

async def main() -> None:
    system_prompt = "You are a helpful assistant that can search the web"
    tools = [
        ChatCompletionToolParam(
            {"type": "function", "function": {"name": "calculator", "description": "Perform mathematical calculations"}}
        )
    ]
    manifest = await generate_capability_manifest(
        system_prompt=system_prompt, tools=tools, provider="openai", model="gpt-5"
    )
    print(manifest)

asyncio.run(main())
```


### Preference Adherence

Evaluates how well an assistant adheres to user preferences.
It first extracts user preferences from messages and then evaluates adherence to **each** of them.

**Metric**: Number of preferences adhered to / total number of preferences

```python
import asyncio

from eval_recipes.evaluations.preference_adherence.preference_adherence_evaluator import (
    InputUserPreferences,
    PreferenceAdherenceEvaluator,
)
from eval_recipes.schemas import BaseEvaluatorConfig

async def main() -> None:
    input_data = InputUserPreferences(
        conversation_history_beginning_turn="""System: You are a helpful assistant. You are concise and avoid emojis in your response
User: What is Python?""",
        conversation_history_full="""System: You are a helpful assistant. You are concise and avoid emojis in your response
User: What is Python?
Assistant: Python is a high-level, interpreted programming language known for simplicity and readability.""",
    )
    config = BaseEvaluatorConfig(model="gpt-5-mini")
    evaluator = PreferenceAdherenceEvaluator(config=config)
    result = await evaluator.run(input_data)
    print(result)

asyncio.run(main())
```


### Tool Usage

Evaluates whether an assistant correctly uses available tools.
Calculates probability that each tool should be called based on conversation context.

**Metric**
- If no tools were called (was_called=False for all)
  - Each probability should be below its threshold. If so, return 100, 0 otherwise.
- If was_called=True for any tool:
  - Check **any** of those tool's probability is above its threshold, if so return 100.
  - Otherwise if none of the "was_called=True" have a probability over the threshold, return 0. (This implies a tool was called when it should not have been)

```python
import asyncio
from eval_recipes.evaluations.tool_usage.tool_usage_evaluator import (
    InputTool,
    InputToolUsageEvaluator,
    ToolUsageEvaluator,
    ToolUsageEvaluatorConfig,
)

async def main() -> None:
    input_data = InputToolUsageEvaluator(
        tools=[
            InputTool(
                tool_name="search",
                tool_text="Search for information on the web",
                was_called=False,
                threshold=50,
            ),
            InputTool(
                tool_name="calculator",
                tool_text="Perform mathematical calculations",
                was_called=True,
                threshold=50,
            ),
        ],
        conversation_history_full="User: What is 15% of 200?\nAssistant: I'll calculate that for you.",
    )
    config = ToolUsageEvaluatorConfig()  # (optionally) configure models and tool thresholds here
    evaluator = ToolUsageEvaluator(config=config)
    result = await evaluator.run(input_data)
    print(result)

asyncio.run(main())
```

## eval_recipes/evaluate.py

# Copyright (c) Microsoft. All rights reserved.

import asyncio

from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.responses import ResponseInputParam

from eval_recipes.evaluations.check_criteria.check_criteria_evaluator import (
    CheckCriteriaEvaluator,
    CheckCriteriaEvaluatorConfig,
)
from eval_recipes.evaluations.claim_verification.claim_verification_evaluator import (
    ClaimVerificationEvaluator,
    ClaimVerificationEvaluatorConfig,
)
from eval_recipes.evaluations.guidance.guidance_evaluator import GuidanceEvaluator, GuidanceEvaluatorConfig
from eval_recipes.evaluations.preference_adherence.preference_adherence_evaluator import PreferenceAdherenceEvaluator
from eval_recipes.evaluations.tool_usage.tool_usage_evaluator import ToolUsageEvaluator, ToolUsageEvaluatorConfig
from eval_recipes.schemas import BaseEvaluatorConfig, EvaluationOutput, EvaluatorProtocol


async def evaluate(
    messages: ResponseInputParam,
    tools: list[ChatCompletionToolParam],
    evaluations: list[str | type[EvaluatorProtocol]],
    evaluation_configs: dict[str, BaseEvaluatorConfig] | None = None,
    max_concurrency: int = 1,
) -> list[EvaluationOutput]:
    """
    Evaluates the model's performance based on the provided messages and tools over the specified evaluations.

    Args:
        messages: OpenAI responses API input messages
        tools: OpenAI tool definitions
        evaluations: The list of evaluation names or custom evaluator classes to perform.
          Built-in options are: "claim_verification", "tool_usage", "guidance", and "preference_adherence".
          You can also pass custom evaluator classes that implement the EvaluatorProtocol.
        evaluation_configs: Optional configs for each evaluation.
          Keys should be the built-in evaluation names or custom evaluator class names.
          If not provided, defaults will be used.
        max_concurrency: Maximum number of evaluations to run concurrently. Default is 1 (sequential).

    Returns:
        A list of EvaluationOutput objects containing the evaluation results.
        Each object includes the evaluation name, score, and optional metadata specific to that evaluation.
    """
    if evaluation_configs is None:
        evaluation_configs = {}

    evaluator_map: dict[str, tuple[type, type[BaseEvaluatorConfig]]] = {
        "guidance": (GuidanceEvaluator, GuidanceEvaluatorConfig),
        "preference_adherence": (PreferenceAdherenceEvaluator, BaseEvaluatorConfig),
        "tool_usage": (ToolUsageEvaluator, ToolUsageEvaluatorConfig),
        "claim_verification": (ClaimVerificationEvaluator, ClaimVerificationEvaluatorConfig),
        "check_criteria": (CheckCriteriaEvaluator, CheckCriteriaEvaluatorConfig),
    }

    semaphore = asyncio.Semaphore(max_concurrency)

    async def run_evaluation(
        eval_item: str | type[EvaluatorProtocol],
    ) -> EvaluationOutput | None:
        async with semaphore:
            # Handle string evaluation names (built-in evaluators)
            if isinstance(eval_item, str):
                if eval_item not in evaluator_map:
                    return None
                evaluator_class, config_type = evaluator_map[eval_item]
                config = evaluation_configs.get(eval_item)
                validated_config = config if isinstance(config, config_type) else None
                evaluator = evaluator_class(config=validated_config)
            # Handle custom evaluator classes
            else:
                # Check if the class implements the required protocol
                if not isinstance(eval_item, type) or not issubclass(eval_item, EvaluatorProtocol):
                    raise ValueError(f"Custom evaluator {eval_item} must be a class that implements EvaluatorProtocol")
                # Get config using the class name
                class_name = eval_item.__name__
                config = evaluation_configs.get(class_name)
                evaluator = eval_item(config=config)

            return await evaluator.evaluate(messages, tools)

    tasks = [run_evaluation(eval_item) for eval_item in evaluations]
    results = await asyncio.gather(*tasks)
    return [result for result in results if result is not None]

## eval_recipes/schemas.py

# Copyright (c) Microsoft. All rights reserved.


from typing import Any, Literal, Protocol, runtime_checkable

from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.responses import ResponseInputParam
from pydantic import BaseModel


class EvaluationOutput(BaseModel):
    eval_name: str  # Name of the evaluation
    applicable: bool  # Was the evaluation applicable
    score: float  # Score from 0 to 100
    feedback: str | None = None  # Feedback that can be used as part of another system to self-improve the response.
    metadata: dict[str, Any] = {}  # Any additional metadata the evaluation may generate.


# region Eval Configurations


class BaseEvaluatorConfig(BaseModel):
    provider: Literal["openai", "azure_openai"] = "openai"
    model: Literal["gpt-5", "gpt-5-mini", "gpt-5-nano", "o3", "o4-mini"] = "gpt-5"


# endregion


@runtime_checkable
class EvaluatorProtocol(Protocol):
    """Protocol for custom evaluator classes."""

    def __init__(self, config: BaseEvaluatorConfig | None = None) -> None:
        """Initialize the evaluator with an optional configuration.
        If config is not provided, it should be instantiated with defaults.
        """
        ...

    async def evaluate(self, messages: ResponseInputParam, tools: list[ChatCompletionToolParam]) -> EvaluationOutput:
        """Evaluate messages and tools, returning an EvaluationOutput."""
        ...
