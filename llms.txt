# Eval Recipes

> **Eval Recipes** is a an evaluation framework that makes it easy to evaluate LLM chat assistants, and does so at a high degree of quality. We use recipes to develop specialized evaluation workflows that score conversations on dimensions such as how well the assistant adhered to user preferences or if they did not generate any hallucinations.

## Attribution Instructions

The built-in `claim_verification` evaluation is based on these two papers: [Claimify](https://arxiv.org/abs/2502.10855) and [VeriTrail](https://arxiv.org/abs/2505.21786). This is not an official implementation of either. Whenever you use the evaluation, please cite the original papers.


## README.md

# Eval Recipes

Eval Recipes is an library dedicated to make it easier to keep up with the state-of-the-art in evaluating AI agents.
It currently has two main components: a **benchmarking** harness for evaluating CLI agents (GitHub Copilot CLI, Claude Code, etc) on real-world tasks via containers and an **online evaluation** framework for LLM chat assistants.
The common thread between these components is the concept of [recipes](https://sundaylettersfromsam.substack.com/p/what-is-an-ai-recipe) 
which are a mix of code and LLM calls to achieve a desired tradeoff between flexibility and quality.


# Benchmarking

Eval Recipes provides a benchmarking harness for evaluating AI agents on real-world tasks in isolated Docker containers.
We have a few sample tasks ranging from creating CLI applications to automations. Agents are automatically scored based on deterministic and semantic tests using a specialized auditing agent.

Additional features include agent continuation (automatically providing follow-up prompts when needed), multi-trial evaluation for consistency measurement, and reporting with HTML dashboards.


## Running Benchmarks

```bash
# The default agents/tasks require these environment variables. Check the agent definitions for others.
export ANTHROPIC_API_KEY=your_anthropic_key
export OPENAI_API_KEY=your_openai_key

uv run scripts/run_benchmarks.py --num-trials 2

# Get more info about available arguments
uv run scripts/run_benchmarks.py --help
```

Results are saved to timestamped directories in `data/benchmarking/runs/` containing agent logs, test outputs, timing data, and structured results.
Any of these files may contain secrets that were used during the evaluation run. **NEVER** commit these files to source control without first checking for secrets.
For detailed documentation on creating custom agents and tasks, see [BENCHMARKING.md](./docs/BENCHMARKING.md).


# Online Evaluations

![Eval Recipes Animation](demos/data/EvalRecipesAnimation.gif)

## Get Started Quick!

### 1. View notebooks directly on GitHub

Located in [demos/](./demos).

### 2. Run interactive notebooks with marimo

Run demo notebooks (the `.py` files located at [demos/](./demos)) with [`marimo`](https://docs.marimo.io/getting_started/installation/).
Follow the installation section below if you do not have `uv` installed or environment variables configured.

```bash
uv run marimo edit demos/1_evaluate.py
# Select Y to run in a sandboxed venv
```

### 3. Start using the package

```bash
uv pip install "git+https://github.com/microsoft/eval-recipes"
```

> [!WARNING]
> This library is very early and everything is subject to change. Consider pinning the dependency to a commit with the command like: `uv pip install "git+https://github.com/microsoft/eval-recipes@v0.0.7"`


## High Level API

The primary way of interacting with the package is the high-level API which takes in a list of messages
(defined by [OpenAI's responses API](https://platform.openai.com/docs/api-reference/responses/create#responses_create-input))
and a list of [custom tool definitions](https://platform.openai.com/docs/api-reference/responses/create#responses_create-tools) (built-in tools are not supported).

Each evaluation will output if it is deemed applicable to your input, an overall `score` from 0 to 100, and additional metadata specific to that evaluation.

Currently there are several built-in evaluations: `claim_verification`, `tool_usage`, `guidance`, and `preference_adherence`.
For more details on how these evaluations work, check the Low Level API section below.
Each evaluation can be additionally configured, such as selecting the LLM used. The full configurations are defined in [schemas.py](./eval_recipes/schemas.py).

`evaluate` will return a list of [`EvaluationOutput`](./eval_recipes/schemas.py) instances corresponding to each evaluation.


> [!TIP]
> All of the code examples in this readme can be pasted into a `.py` file and run as is!

```python
import asyncio
from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.responses import EasyInputMessageParam, ResponseInputParam
from eval_recipes.evaluate import evaluate
from eval_recipes.evaluations.check_criteria.check_criteria_evaluator import CheckCriteriaEvaluatorConfig
from eval_recipes.schemas import BaseEvaluatorConfig

async def main() -> None:
    messages: ResponseInputParam = [
        EasyInputMessageParam(
            role="system", content="You are a helpful assistant with search and document editing capabilities."
        ),
        EasyInputMessageParam(
            role="user",
            content="What material has the best elasticity for sports equipment? Please keep your response concise.",
        ),
        EasyInputMessageParam(
            role="assistant",
            content="Polyurethane elastomers offer excellent elasticity with 85% energy return and high durability.",
        ),
    ]

    tools: list[ChatCompletionToolParam] = [
        ChatCompletionToolParam(
            type="function",
            function={
                "name": "search",
                "description": "Search for information",
                "parameters": {"type": "object", "properties": {"query": {"type": "string"}}, "required": ["query"]},
            },
        ),
    ]
    config_preference_adherence = BaseEvaluatorConfig(model="gpt-5-mini")  # Sample config
    check_criteria = CheckCriteriaEvaluatorConfig(criteria=["Your response should be at least one paragraph long."])
    result = await evaluate(
        messages=messages,
        tools=tools,
        evaluations=["check_criteria", "claim_verification", "guidance", "preference_adherence", "tool_usage"],
        evaluation_configs={"preference_adherence": config_preference_adherence, "check_criteria": check_criteria},
        max_concurrency=1,
    )
    print(result)

asyncio.run(main())
```


### Custom Evaluations

You can create custom evaluators by implementing a class that follows the [`EvaluatorProtocol`](./eval_recipes/schemas.py).
This allows you to extend the evaluation framework with domain-specific metrics tailored to your needs.

Custom evaluators must implement:
1. An `__init__` method that accepts an optional `BaseEvaluatorConfig` parameter. If a config is not provided, you must initialize a default.
2. An async `evaluate` method that takes messages and tools as input and returns an `EvaluationOutput`

Here is an example of a custom evaluator that scores based on the length of the assistant's response being used in conjunction with the `preference_adherence` evaluator:

```python
import asyncio
from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.responses import EasyInputMessageParam, ResponseInputParam
from eval_recipes.evaluate import evaluate
from eval_recipes.schemas import BaseEvaluatorConfig, EvaluationOutput

class ResponseLengthEvaluator:
    """Custom evaluator that scores based on response brevity."""
    def __init__(self, config: BaseEvaluatorConfig | None = None) -> None:
        self.config = config or BaseEvaluatorConfig()

    async def evaluate(self, messages: ResponseInputParam, tools: list[ChatCompletionToolParam]) -> EvaluationOutput:
        total_length = 0
        for message in reversed(messages):  # Only look at the last assistant message
            if ("role" in message and message["role"] == "assistant") and message.get("content"):
                total_length += len(str(message["content"]))
                break

        score = max(0, 100 - int(total_length // 25))  # Decrease score as length increases
        return EvaluationOutput(eval_name="response_length", applicable=True, score=score, metadata={})

async def main() -> None:
    messages: ResponseInputParam = [
        EasyInputMessageParam(
            role="user",
            content="What material has the best elasticity for sports equipment? Please keep your response concise.",
        ),
        EasyInputMessageParam(
            role="assistant",
            content="Polyurethane elastomers offer excellent elasticity with 85% energy return and high durability.",
        ),
    ]
    result = await evaluate(
        messages=messages,
        tools=[],
        evaluations=[ResponseLengthEvaluator, "preference_adherence"],
        evaluation_configs={"ResponseLengthEvaluator": BaseEvaluatorConfig(model="gpt-5-mini")},
        max_concurrency=1,
    )
    print(result)

asyncio.run(main())
```


## Development Installation
### Prerequisites
- make
  - For Windows, you can download it using [UniGetUI](https://github.com/marticliment/UnigetUI) and use [ezwinports make](https://github.com/microsoft/winget-pkgs/tree/master/manifests/e/ezwinports/make)
- [uv](https://docs.astral.sh/uv/getting-started/installation/)

### Install Dependencies & Configure Environment

```bash
make install
cp .env.sample .env
# Configure API keys in .env
# Make sure the venv gets activated
. .venv/bin/activate # Linux example
```

This library requires either OpenAI or Azure OpenAI to be configured. You must set the correct environment variables in the `.env` file.

The `semantic_test` evaluator additionally requires `ANTHROPIC_API_KEY` to be set, as it uses the Claude Agent SDK.

Check [utils.py `create_client`](./eval_recipes/utils/llm.py) to troubleshoot any configuration issues.

### Other

- [Generating Jupyter Notebooks](./docs/NOTEBOOKS.md)
- To re-create the [Manim](https://www.manim.community/) animation:
  - `make install-all` to install manim. See the docs if you have issues on a Linux-based system. Note this will also require `ffmpeg` to be installed.
  - `uv run manim scripts/create_animation.py EvalRecipesAnimation -qh && ffmpeg -y -i media/videos/create_animation/1080p60/EvalRecipesAnimation.mp4 -vf "fps=30,scale=1920:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 demos/data/EvalRecipesAnimation.gif`
- [Validating Evaluations](./tests/validate_evaluations.py):
  - This script will run evaluations against a small "goldset" (see [data/goldset](data/goldset/)) where we have inputs to evaluate with labels of what the scores should be (defined in [data/goldset/labels.yaml](data/goldset/labels.yaml)).


## Low Level API

[LOW_LEVEL_API.md](./docs/LOW_LEVEL_API.md)


## Changelog

[CHANGELOG.md](./docs/CHANGELOG.md)


## Roadmap

[ROADMAP.md](./docs/ROADMAP.md)


## Attributions

The built-in `claim_verification` evaluation is based on these two papers: [Claimify](https://arxiv.org/abs/2502.10855) and [VeriTrail](https://arxiv.org/abs/2505.21786). This is not an official implementation of either and please cite the original papers if you use this evaluation in your work.

## docs/LOW_LEVEL_API.md

## Low Level API

We provide the low level API because the high level API makes assumptions about the structure of
your messages, tools, and how they are used in the evaluation.
For example, claim verification automatically ignores any assistant messages from the data that is verified against.
The low level API for each evaluation typically allows for more granular control of how to handle the data you'd like to be evaluated.


### Check Criteria

Evaluates assistant responses against custom criteria or rubrics you define. This is a useful "catch-all" evaluation for simpler requirements like tone, format, or content guidelines.

**Metric**: Average probability across all criteria (0-100), where each criterion is evaluated independently

```python
import asyncio

from eval_recipes.evaluations.check_criteria.check_criteria_evaluator import (
    CheckCriteriaEvaluator,
    CheckCriteriaEvaluatorConfig,
)

async def main() -> None:
    config = CheckCriteriaEvaluatorConfig(
        criteria=[
            "The response should be exactly one paragraph",
            "The response should end with a question",
        ],
        passed_threshold=75,  # Criteria scoring below 75% will be included in feedback
        model="gpt-5-mini",
    )
    evaluator = CheckCriteriaEvaluator(config=config)
    messages = [
        {"role": "user", "content": "What is a programming language?"},
        {
            "role": "assistant",
            "content": "A programming language is a formal system of instructions that computers can execute. Popular examples include Python, JavaScript, and Java. Each language has its own syntax and use cases. What type of programming are you interested in learning?"
        }
    ]
    
    result = await evaluator.evaluate(messages, tools=[])
    print(f"Score: {result.score:.1f}%")
    print(f"Feedback: {result.feedback}")
    for eval in result.metadata["criteria_evaluations"]:
        print(f"- {eval['criterion']}: {eval['probability']*100:.0f}%")

asyncio.run(main())
```


### Claim Verification

Verifies factual claims in text against source context.
Implemented as AsyncGenerator that yields partial results as claims are verified.

This evaluation is based on the following two papers: [Claimify](https://arxiv.org/abs/2502.10855) and [VeriTrail](https://arxiv.org/abs/2505.21786).
This is not an official implementation of either and please cite the original papers if you use this evaluation in your work.

**Metric**: Number of verified claims / (total number of claims - number of "open-domain" claims)

```python
import asyncio

from eval_recipes.evaluations.claim_verification.claim_verification_evaluator import (
    ClaimVerificationEvaluator,
    ClaimVerificationEvaluatorConfig,
    InputClaimVerificationEvaluator,
    InputContext,
)

async def main() -> None:
    input_data = InputClaimVerificationEvaluator(
        text="Paris is the capital of France. It has 12 million residents.",
        user_question="Tell me about Paris",
        source_context=[
            InputContext(
                source_id="1",
                title="Wikipedia",
                content="Paris is the capital city of France with 2.1 million inhabitants.",
            )
        ],
    )
    config = ClaimVerificationEvaluatorConfig()  # (optionally) configure models and other parameters here
    verifier = ClaimVerificationEvaluator(config=config)
    async for result in verifier.run(input_data):
        print(result)

asyncio.run(main())
```


### Guidance

Evaluates how gracefully an assistant handles out-of-scope requests.
Determines if requests are within capabilities and evaluates response quality for out-of-scope requests.

```python
import asyncio
from eval_recipes.evaluations.guidance.guidance_evaluator import (
    GuidanceEvaluator,
    GuidanceEvaluatorConfig,
    InputGuidanceEval,
)

async def main() -> None:
    input_data = InputGuidanceEval(
        conversation_history_full="""System: You can help with text tasks.
User: Can you create an Excel spreadsheet for me?
Assistant: I cannot create Excel files, but I can help you create a CSV text file that can be opened in Excel.""",
        conversation_history_beginning_turn="""System: You can help with text tasks.
User: Can you create an Excel spreadsheet for me?""",
    )
    config = GuidanceEvaluatorConfig(
        capability_manifest="## Capabilities\n- Create and edit text files\n- Cannot create binary files like Excel spreadsheets"
    )  # (recommended) provide the capability manifest or it will be auto-generated
    evaluator = GuidanceEvaluator(config=config)
    result = await evaluator.run(input_data)
    print(result)

asyncio.run(main())
```

The `generate_capability_manifest` function helps create the capability_manifest from system prompts and tool definitions
This is useful for preprocessing noisy system prompts into clear capability descriptions.

```python
import asyncio
from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from eval_recipes.evaluations.guidance.guidance_evaluator import generate_capability_manifest

async def main() -> None:
    system_prompt = "You are a helpful assistant that can search the web"
    tools = [
        ChatCompletionToolParam(
            {"type": "function", "function": {"name": "calculator", "description": "Perform mathematical calculations"}}
        )
    ]
    manifest = await generate_capability_manifest(
        system_prompt=system_prompt, tools=tools, provider="openai", model="gpt-5"
    )
    print(manifest)

asyncio.run(main())
```


### Preference Adherence

Evaluates how well an assistant adheres to user preferences.
It first extracts user preferences from messages and then evaluates adherence to **each** of them.

**Metric**: Number of preferences adhered to / total number of preferences

```python
import asyncio

from eval_recipes.evaluations.preference_adherence.preference_adherence_evaluator import (
    InputUserPreferences,
    PreferenceAdherenceEvaluator,
)
from eval_recipes.schemas import BaseEvaluatorConfig

async def main() -> None:
    input_data = InputUserPreferences(
        conversation_history_beginning_turn="""System: You are a helpful assistant. You are concise and avoid emojis in your response
User: What is Python?""",
        conversation_history_full="""System: You are a helpful assistant. You are concise and avoid emojis in your response
User: What is Python?
Assistant: Python is a high-level, interpreted programming language known for simplicity and readability.""",
    )
    config = BaseEvaluatorConfig(model="gpt-5-mini")
    evaluator = PreferenceAdherenceEvaluator(config=config)
    result = await evaluator.run(input_data)
    print(result)

asyncio.run(main())
```


### Tool Usage

Evaluates whether an assistant correctly uses available tools.
Calculates probability that each tool should be called based on conversation context.

**Metric**
- If no tools were called (was_called=False for all)
  - Each probability should be below its threshold. If so, return 100, 0 otherwise.
- If was_called=True for any tool:
  - Check **any** of those tool's probability is above its threshold, if so return 100.
  - Otherwise if none of the "was_called=True" have a probability over the threshold, return 0. (This implies a tool was called when it should not have been)

```python
import asyncio
from eval_recipes.evaluations.tool_usage.tool_usage_evaluator import (
    InputTool,
    InputToolUsageEvaluator,
    ToolUsageEvaluator,
    ToolUsageEvaluatorConfig,
)

async def main() -> None:
    input_data = InputToolUsageEvaluator(
        tools=[
            InputTool(
                tool_name="search",
                tool_text="Search for information on the web",
                was_called=False,
                threshold=50,
            ),
            InputTool(
                tool_name="calculator",
                tool_text="Perform mathematical calculations",
                was_called=True,
                threshold=50,
            ),
        ],
        conversation_history_full="User: What is 15% of 200?\nAssistant: I'll calculate that for you.",
    )
    config = ToolUsageEvaluatorConfig()  # (optionally) configure models and tool thresholds here
    evaluator = ToolUsageEvaluator(config=config)
    result = await evaluator.run(input_data)
    print(result)

asyncio.run(main())
```


### Semantic Test

Evaluates agent work by using an AI agent to audit deliverables against custom steps and rubrics.
The auditor agent explores a working directory, follows specified steps, and completes a structured rubric.

**Metric**: Score extracted from the completed rubric (0-100).

```python
import asyncio
from pathlib import Path

from eval_recipes.evaluations.semantic_test.semantic_test_evaluator import (
    SemanticTestEvaluator,
    SemanticTestEvaluatorConfig,
)

async def main() -> None:
    # Setup: working_dir should contain the agent's deliverables
    working_dir = Path("/path/to/agent/work")

    context = "Create a Python script that calculates fibonacci numbers using recursion"

    steps = """1. Check if the Python file exists
1. Read the file and verify it implements fibonacci using recursion
2. Test the implementation by running it"""

    rubric = {
        "file_exists": "20 points boolean - does the file exist?",
        "uses_recursion": "40 points boolean - does it use recursion?",
        "works_correctly": "40 points boolean - does it produce correct results?",
        "score": "number (0-100) - total score based on criteria above",
    }

    config = SemanticTestEvaluatorConfig(
        working_dir=working_dir,
        steps=steps,
        rubric=rubric,
        context=context,
    )
    evaluator = SemanticTestEvaluator(config=config)
    result = await evaluator.run(
        working_dir=working_dir,
        steps=steps,
        rubric=rubric,
        context=context,
    )
    print(f"Score: {result.score:.1f}")
    print(f"Feedback: {result.feedback}")
    print(f"Metadata: {result.metadata}")

asyncio.run(main())
```

## docs/BENCHMARKING.md

# Benchmarking

This module provides a benchmarking harness for evaluating AI agents on real-world tasks within isolated Docker containers.

The goal of the module is to produce a final report that details how well each agent performed on a variety of custom tasks.

The core of the module is a harness that uses agent definitions (defaults in `data/agents/`) 
and task definitions (defaults in `data/tasks/`) to run agents on tasks, each their own isolated Docker containers.
After each agent has been run on a task, the task's `test.py` script is executed to validate the agent's solution and produce a score.
For each agent-task pair that scores below a threshold, a report is generated that analyzes what went wrong.
Finally, these individual reports are rolled up into a final report for each agent.


## Prerequisites

- [uv](https://docs.astral.sh/uv/getting-started/installation/)
- [Docker](https://docs.docker.com/engine/install/ubuntu/)
  - After installing, ensure your user has docker permissions by running:
    - `sudo usermod -aG docker $USER`
    - `newgrp docker`
- Claude Agent SDK which requires [Claude Code](https://docs.claude.com/en/docs/claude-code/overview)
- ANTHROPIC_API_KEY for the Claude Agent SDK.


## Running Benchmarks

The benchmarking harness is available via the CLI script `scripts/run_benchmarks.py`.

### Basic Usage

```bash
# Make sure your .env file is setup according to .env.sample
# Run all agents on all tasks, by default this will use the existing data/agents/ and data/tasks/ directories
uv run scripts/run_benchmarks.py --max-parallel-tasks 3

# You can also specify various filters
uv run scripts/run_benchmarks.py --agent-filter name=claude_code --task-filter name=your_task_name
```


## Creating a New Agent

Agents are defined in the `data/agents/` directory.
Each agent is a subdirectory containing the files needed to install and run the agent.
Included agents are located in [data/agents/](../data/agents/).

```
data/agents/your_agent_name/
agent.yaml                     # Agent configuration
install.dockerfile             # Docker commands to install the agent
command_template.txt           # Liquid template for the command to run the agent
command_template_continue.txt  # (Optional) Template for agent continuation when follow-up is needed. This command must continue from the previous session/conversation.
data/                          # (Optional) Agent-specific data files
```

See [data/agents/gh_cli/](../data/agents/gh_cli/) for an example agent definition.


## Using Local Agent Versions

For development and testing, create agent variants that use local source code instead of remote repositories. This enables rapid iteration on agent improvements while testing against benchmarks.

### Creating a Local Agent Variant

1. Create a new agent directory (e.g., `data/agents/your_agent_local/`)
2. Add `agent.yaml` with `local_source_path` pointing to your local source:
   ```yaml
   local_source_path: /absolute/path/to/your/agent/source
   required_env_vars:
     - API_KEY
   ```
3. Create `install.dockerfile` that installs from `/tmp/agent_source/` (where source is automatically copied)
4. Copy or create `command_template.txt`


### How It Works

1. Harness validates `local_source_path` exists
2. Collects files, respecting `.gitignore` if present (otherwise excludes `.git`, `.venv`, `__pycache__`, etc.)
3. Adds files to Docker build context as `agent_source/`
4. Copies `agent_source` to `/tmp/agent_source/` in container
5. Your `install.dockerfile` installs from there. This dockerfile should install the agent so that it is globally available. The commands will run in `/project/`, not where the agent's files are.
6. Image is rebuilt each run, capturing your latest changes

### Usage

```bash
# Run with local version
uv run scripts/run_benchmarks.py --agent-filter name=your_agent_local

# Compare local vs production
uv run scripts/run_benchmarks.py --agent-filter name=your_agent,your_agent_local
```

**Notes**: `local_source_path` must be absolute. Build time includes copying all source files. Images rebuild automatically to capture code changes.


## Creating a New Task

Tasks are defined in the `data/tasks/` directory. 
Each task is a subdirectory containing the files needed to define the task and test the agent's solution.
Included tasks are available at [data/tasks/](../data/tasks/).


### Task Directory Structure

A template task is available at **[data/_template_task/](../data/_template_task/)** that you can copy as a starting point. The `/create-benchmark-test` command can automate this for you.

```
data/tasks/your_task_name/
task.yaml            # Task configuration (required)
instructions.txt     # Instructions given to the agent (required)
test.py              # Python script to test the agent's solution (required)
setup.dockerfile     # (Optional) Docker commands to set up the task environment
data/                # (Optional) Directory containing test data files
```

### File Descriptions

#### `task.yaml` (Required)

Required fields:
- `task_info`: Object containing:
  - `difficulty`: One of `easy`, `medium`, or `hard`
  - `non_deterministic_evals`: Boolean indicating if test evaluations are non-deterministic (e.g., semantic tests using LLMs)

Optional task_info fields:
- `categories`: List of strings categorizing the task (e.g., `["cli", "automation"]`)

Optional fields:
- `required_env_vars`: List of environment variables required for the task (e.g., API keys for evaluation)
- `test_command`: Command to run the test script (default: `uv run --no-project /project/test.py`)
- `timeout`: Timeout in seconds for agent execution

#### `setup.dockerfile` (Optional)

Contains Docker `RUN` commands to install any dependencies needed for the task or tests. This should be kept minimal, only include resources the agent would not be able to configure themselves.

#### `data/` (Optional)

Optional directory containing test data files that will be copied into the container and made available to `test.py`. This is useful for:
- Providing sample inputs for the agent to work with
- Supplying reference data for semantic tests to validate against
- Making tests more deterministic and reproducible

Examples: See `data/tasks/style_blender/data/` and `data/tasks/email_drafting/data/`

#### `instructions.txt` (Required)
Plain text instructions that will be passed to the agent. This describes what the agent should build or solve.

#### `test.py` (Required)
A Python test script that validates the agent's solution and outputs a score.

All test scripts must follow a standardized contract for integration with the harness. See **[data/_template_task/test.py](../data/_template_task/test.py)** for the complete contract specification, detailed documentation, and a reference implementation you can copy when creating new tasks.


### Semantic Tests

Many tasks use semantic tests. They are tests where an LLM "auditor" follows specific steps and evaluates outputs against a rubric. This is useful for complex tasks where deterministic validation is difficult.
See **[data/tasks/style_blender/test.py](../data/tasks/style_blender/test.py)** and **[data/tasks/email_drafting/test.py](../data/tasks/email_drafting/test.py)** for examples of these.


### Helper Commands for Task Creation

Two slash commands are available to help create high-quality benchmark tasks:
- [`/create-benchmark-test`](../.claude/commands/create-benchmark-test.md) - Guides you through creating a complete new benchmark task
- [`/create-semantic-tests`](../.claude/commands/create-semantic-tests.md) - Helps design semantic tests for a task


## Multi-Trial Evaluation

The harness supports running multiple trials of the same agent-task pair to measure consistency and reliability. Use `--num-trials N` to run each task N times.
Results are aggregated with statistics including mean, median, standard deviation, minimum, and maximum scores.
Each trial is stored in a separate subdirectory (`trial_1`, `trial_2`, etc.) within the results directory, and an `aggregated_results.json` file contains the statistical summary.


## Command-Line Options

The `scripts/run_benchmarks.py` script accepts the following options:

- `--agents-dir`: Path to agents directory (default: `data/agents/`)
- `--tasks-dir`: Path to tasks directory (default: `data/tasks/`)
- `--runs-dir`: Output directory for results (default: `.benchmark_results`)
- `--agent-filter`: Filter agents by field (format: `field=value`, `field!=value`, or `field=val1,val2` for multiple)
- `--task-filter`: Filter tasks by field (same format as agent-filter)
- `--generate-reports`: Generate failure analysis reports (default: True)
- `--max-parallel-tasks`: Maximum number of tasks to run in parallel (default: 22)
- `--num-trials`: Number of trials per agent-task pair (default: 2)
- `--enable-agent-continuation/--disable-agent-continuation`: Toggle agent continuation feature (default: enabled)
- `--report-score-threshold`: Score threshold for generating failure reports (default: 85.0)


## Results

Results include detailed metrics:
- **Scores**: Task-specific scores from test scripts
- **Timing**: Agent execution duration and test execution duration
- **Reports**: Three types of reports are generated:
  - **Trial failure reports**: Individual analysis for each trial scoring below the threshold
  - **Consolidated reports**: Per-agent summary of all failures
  - **HTML reports**: Interactive dashboards with tabbed interface showing overview, task catalog, and per-agent detailed results

## Notes

- You may want to prune your Docker images and containers periodically to save space. Containers/images can hang around when runs are unexpectedly interrupted.

## eval_recipes/evaluate.py

# Copyright (c) Microsoft. All rights reserved.

import asyncio

from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.responses import ResponseInputParam

from eval_recipes.evaluations.check_criteria.check_criteria_evaluator import (
    CheckCriteriaEvaluator,
    CheckCriteriaEvaluatorConfig,
)
from eval_recipes.evaluations.claim_verification.claim_verification_evaluator import (
    ClaimVerificationEvaluator,
    ClaimVerificationEvaluatorConfig,
)
from eval_recipes.evaluations.guidance.guidance_evaluator import GuidanceEvaluator, GuidanceEvaluatorConfig
from eval_recipes.evaluations.preference_adherence.preference_adherence_evaluator import PreferenceAdherenceEvaluator
from eval_recipes.evaluations.tool_usage.tool_usage_evaluator import ToolUsageEvaluator, ToolUsageEvaluatorConfig
from eval_recipes.schemas import BaseEvaluatorConfig, EvaluationOutput, EvaluatorProtocol


async def evaluate(
    messages: ResponseInputParam,
    tools: list[ChatCompletionToolParam],
    evaluations: list[str | type[EvaluatorProtocol]],
    evaluation_configs: dict[str, BaseEvaluatorConfig] | None = None,
    max_concurrency: int = 1,
) -> list[EvaluationOutput]:
    """
    Evaluates the model's performance based on the provided messages and tools over the specified evaluations.

    Args:
        messages: OpenAI responses API input messages
        tools: OpenAI tool definitions
        evaluations: The list of evaluation names or custom evaluator classes to perform.
          Built-in options are: "claim_verification", "tool_usage", "guidance", and "preference_adherence".
          You can also pass custom evaluator classes that implement the EvaluatorProtocol.
        evaluation_configs: Optional configs for each evaluation.
          Keys should be the built-in evaluation names or custom evaluator class names.
          If not provided, defaults will be used.
        max_concurrency: Maximum number of evaluations to run concurrently. Default is 1 (sequential).

    Returns:
        A list of EvaluationOutput objects containing the evaluation results.
        Each object includes the evaluation name, score, and optional metadata specific to that evaluation.
    """
    if evaluation_configs is None:
        evaluation_configs = {}

    evaluator_map: dict[str, tuple[type, type[BaseEvaluatorConfig]]] = {
        "guidance": (GuidanceEvaluator, GuidanceEvaluatorConfig),
        "preference_adherence": (PreferenceAdherenceEvaluator, BaseEvaluatorConfig),
        "tool_usage": (ToolUsageEvaluator, ToolUsageEvaluatorConfig),
        "claim_verification": (ClaimVerificationEvaluator, ClaimVerificationEvaluatorConfig),
        "check_criteria": (CheckCriteriaEvaluator, CheckCriteriaEvaluatorConfig),
    }

    semaphore = asyncio.Semaphore(max_concurrency)

    async def run_evaluation(
        eval_item: str | type[EvaluatorProtocol],
    ) -> EvaluationOutput | None:
        async with semaphore:
            # Handle string evaluation names (built-in evaluators)
            if isinstance(eval_item, str):
                if eval_item not in evaluator_map:
                    return None
                evaluator_class, config_type = evaluator_map[eval_item]
                config = evaluation_configs.get(eval_item)
                validated_config = config if isinstance(config, config_type) else None
                evaluator = evaluator_class(config=validated_config)
            # Handle custom evaluator classes
            else:
                # Check if the class implements the required protocol
                if not isinstance(eval_item, type) or not issubclass(eval_item, EvaluatorProtocol):
                    raise ValueError(f"Custom evaluator {eval_item} must be a class that implements EvaluatorProtocol")
                # Get config using the class name
                class_name = eval_item.__name__
                config = evaluation_configs.get(class_name)
                evaluator = eval_item(config=config)

            return await evaluator.evaluate(messages, tools)

    tasks = [run_evaluation(eval_item) for eval_item in evaluations]
    results = await asyncio.gather(*tasks)
    return [result for result in results if result is not None]

## eval_recipes/schemas.py

# Copyright (c) Microsoft. All rights reserved.


from typing import Any, Literal, Protocol, runtime_checkable

from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam
from openai.types.responses import ResponseInputParam
from pydantic import BaseModel


class EvaluationOutput(BaseModel):
    eval_name: str  # Name of the evaluation
    applicable: bool  # Was the evaluation applicable
    score: float  # Score from 0 to 100
    feedback: str | None = None  # Feedback that can be used as part of another system to self-improve the response.
    metadata: dict[str, Any] = {}  # Any additional metadata the evaluation may generate.


# region Eval Configurations


class BaseEvaluatorConfig(BaseModel):
    provider: Literal["openai", "azure_openai"] = "openai"
    model: Literal["gpt-5", "gpt-5-mini", "gpt-5-nano", "o3", "o4-mini"] = "gpt-5"


# endregion


@runtime_checkable
class EvaluatorProtocol(Protocol):
    """Protocol for custom evaluator classes."""

    def __init__(self, config: BaseEvaluatorConfig | None = None) -> None:
        """Initialize the evaluator with an optional configuration.
        If config is not provided, it should be instantiated with defaults.
        """
        ...

    async def evaluate(self, messages: ResponseInputParam, tools: list[ChatCompletionToolParam]) -> EvaluationOutput:
        """Evaluate messages and tools, returning an EvaluationOutput."""
        ...

## scripts/run_benchmarks.py

# Copyright (c) Microsoft. All rights reserved

import asyncio
import os
from pathlib import Path

import click
from dotenv import load_dotenv
from rich.console import Console
from rich.panel import Panel

from eval_recipes.benchmarking.harness import Harness

load_dotenv()


@click.command()
@click.option(
    "--agents-dir",
    type=click.Path(exists=True, file_okay=False, path_type=Path),
    default=lambda: Path(__file__).parents[1] / "data" / "agents",
    help="Directory containing agent configurations",
)
@click.option(
    "--tasks-dir",
    type=click.Path(exists=True, file_okay=False, path_type=Path),
    default=lambda: Path(__file__).parents[1] / "data" / "tasks",
    help="Directory containing task definitions",
)
@click.option(
    "--runs-dir",
    type=click.Path(file_okay=False, path_type=Path),
    default=lambda: Path(__file__).parents[1] / ".benchmark_results",
    help="Directory to store benchmark run results",
)
@click.option(
    "--agent-filter",
    "agent_filters",
    multiple=True,
    default=(),
    help="Filter agents by field. Format: field=value or field=value1,value2 or field!=value (negation). "
    "Can specify multiple times (AND logic). Examples: name=claude_code or name!=old_agent",
)
@click.option(
    "--task-filter",
    "task_filters",
    multiple=True,
    default=("name=!sec_10q_extractor",),
    help="Filter tasks by field. Format: field=value or field.nested=value1,value2 or field!=value (negation). "
    "Can specify multiple times (AND logic). Examples: difficulty=medium or name!=sec_10q_extractor",
)
@click.option(
    "--generate-reports",
    is_flag=True,
    default=True,
    help="Generate failure reports for each task, a consolidated summary report, and an HTML report",
)
@click.option(
    "--max-parallel-tasks",
    type=int,
    default=1,
    help="Maximum number of tasks to run in parallel",
)
@click.option(
    "--num-trials",
    type=int,
    default=1,
    help="Number of times to run each task",
)
@click.option(
    "--enable-agent-continuation/--disable-agent-continuation",
    default=True,
    help="Enable or disable agent continuation checks",
)
@click.option(
    "--report-score-threshold",
    type=float,
    default=85.0,
    help="Minimum score threshold to skip report generation (reports generated for scores below this)",
)
def main(
    agents_dir: Path,
    tasks_dir: Path,
    runs_dir: Path,
    agent_filters: tuple[str, ...],
    task_filters: tuple[str, ...],
    generate_reports: bool,
    max_parallel_tasks: int,
    num_trials: int,
    enable_agent_continuation: bool,
    report_score_threshold: float,
) -> None:
    """Run benchmarks for LLM agents."""
    harness = Harness(
        agents_dir=agents_dir,
        tasks_dir=tasks_dir,
        runs_dir=runs_dir,
        environment={
            "ANTHROPIC_API_KEY": os.environ["ANTHROPIC_API_KEY"],
            "OPENAI_API_KEY": os.environ["OPENAI_API_KEY"],
            "GITHUB_TOKEN": os.environ.get("GITHUB_TOKEN", ""),
            "AZURE_OPENAI_ENDPOINT": os.environ.get("AZURE_OPENAI_ENDPOINT", ""),
        },
        agent_filters=list(agent_filters) if agent_filters else None,
        task_filters=list(task_filters) if task_filters else None,
        max_parallel_tasks=max_parallel_tasks,
        num_trials=num_trials,
        enable_agent_continuation=enable_agent_continuation,
        report_score_threshold=report_score_threshold,
    )
    asyncio.run(harness.run(generate_reports=generate_reports))

    console = Console()
    console.print()
    console.print(
        Panel(
            "Any of the files generated in the benchmarking run may contain secrets that were used during the evaluation run. "
            "[bold red]NEVER[/bold red] commit these files to source control without first checking for exposed secrets.",
            title="[yellow]âš  Security Warning[/yellow]",
            border_style="yellow",
        )
    )


if __name__ == "__main__":
    main()
